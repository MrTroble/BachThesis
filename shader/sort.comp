#version 460

#define FLT_MAX 3.402823466e+38

layout (binding=0) uniform Camera {
    mat4 model;
    mat4 view;
    mat4 proj;
    mat4 whole;
    mat4 inverseM;
    vec4 colorDepth;
} camera;
layout (binding=1) buffer Index {
    uvec4 data[];
} index;
layout (binding=2) buffer Vertex {
    vec4 vertexData[];
} vertex;
layout(binding=3) buffer block {
    uint toSort[];
};
layout(binding=4) buffer block2 {
    vec4 midpoints[];
};

layout(push_constant) uniform amount {
    uint k;
    uint j;
};

float aboveLine(vec2 l1, vec2 l2, vec2 p) {
    vec2 Md = l2 - l1;
    vec2 n = vec2(Md.y, -Md.x);
    vec2 dir = l1 - p;
    return dot(normalize(n), dir);
}

float distToLine(vec2 l1, vec2 l2, vec2 p) {
    return abs(aboveLine(l1, l2, p));
}

bool checkIn(vec3 inPoints[4], vec2 p) {
    const float s1 = sign(aboveLine(inPoints[0].xy, inPoints[1].xy, p));
    const float s2 = sign(aboveLine(inPoints[1].xy, inPoints[2].xy, p));
    if(s2 != s1)
        return false;
    const float s3 = sign(aboveLine(inPoints[2].xy, inPoints[3].xy, p));
    if(s2 != s3)
        return false;
    const float s4 = sign(aboveLine(inPoints[3].xy, inPoints[0].xy, p));
    if(s4 != s3)
        return false;
    return true;
}

uint[5] sortPoints(vec3[4] screenSpace, uint mostLeft, uint mostRight) {
    uint[5] values;
    float distanceToLine = 0;
    uint mostDistantOne = 4;
    uint otherDist = 4;
    for(uint x = 0; x < 4; x++) {
        if(mostRight == x || mostLeft == x) {
            continue;
        }
        float dist = distToLine(screenSpace[mostLeft].xy, screenSpace[mostRight].xy, screenSpace[x].xy);
        if(dist > distanceToLine) {
            distanceToLine = dist;
            mostDistantOne = x;
            if(otherDist == 4)
                otherDist = mostDistantOne;
        } else {
            otherDist = x;
        }
    }

    vec2 P2 = screenSpace[mostDistantOne].xy;
    vec2 dP0 = screenSpace[mostLeft].xy - P2;
    vec2 dP1 = screenSpace[mostRight].xy - P2;
    vec2 dP3 = screenSpace[otherDist].xy - P2;
    float faktor = dP0.y * dP1.x - dP0.x * dP1.y;
    // Multiply inverse
    vec2 lambdas = vec2(dP1.x * dP3.y - dP1.y * dP3.x, dP0.y * dP3.x - dP0.x * dP3.y) / faktor;
    float lambda2 = 1.0f - lambdas.y - lambdas.x;
    if(lambdas.x <= 0.0f || lambdas.y <= 0.0f || lambda2 <= 0.0f) {
        // Case 2
        float p2Dist = aboveLine(screenSpace[mostLeft].xy, screenSpace[mostRight].xy, P2);
        float p3Dist = aboveLine(screenSpace[mostLeft].xy, screenSpace[mostRight].xy, screenSpace[otherDist].xy);

        if(sign(p2Dist) != sign(p3Dist)) {
            // Case: Line is bisecting the quad
            values[0] = mostLeft;
            values[1] = otherDist;
            values[2] = mostRight;
            values[3] = mostDistantOne;
            // 4 points on edge
            values[4] = 4;
            return values;
        } 
        // Case: We need to find the bisection point
        vec2 baseline = normalize(screenSpace[mostRight].xy - screenSpace[mostLeft].xy);
        
        float w1 = dot(baseline, normalize(screenSpace[mostRight].xy - screenSpace[otherDist].xy));
        float w2 = dot(baseline, normalize(screenSpace[mostRight].xy - screenSpace[mostDistantOne].xy));

        values[0] = mostLeft;
        values[1] = otherDist;
        values[3] = mostDistantOne;
        values[2] = mostRight;
        if(w1 < w2) {
            values[1] = mostDistantOne;
            values[3] = otherDist;
        }
        // 4 points on edge
        values[4] = 4;
        return values;
    }
    // Case: We have a triangle
    values[0] = mostLeft;
    values[1] = mostRight;
    values[3] = mostDistantOne;
    // 4 points on edge
    values[4] = 3;
    return values;
} 

bool getTestPoint(vec3[4] screenSpace1, uint[5] index1, vec3[4] screenSpace2, uint[5] index2, out vec2 pointToCheck) {
    return false;
}

void compareAndSwap(uint v1, uint v2) {
    uint maxSize = toSort.length();
    if(maxSize <= v1 || maxSize <= v2)
        return;
    vec3 screenSpace1[4];
    vec3 screenSpace2[4];
    vec2 min1 = vec2(FLT_MAX), max1 = vec2(-FLT_MAX);
    vec2 min2 = vec2(FLT_MAX), max2 = vec2(-FLT_MAX);
    uint left1 = 5, left2 = 5, right1 = 5, right2 = 5;
    uvec4 tetrahedron1 = index.data[toSort[v1]];
    for(uint i = 0; i < 4; i++) {
        vec4 values = camera.whole * vertex.vertexData[tetrahedron1[i]];
        vec3 screen = values.xyz / values.w;
        screenSpace1[i] = screen;
        min1 = min(min1, screen.xy);
        max1 = max(max1, screen.xy);
    }
    uvec4 tetrahedron2 = index.data[toSort[v2]];
    for(uint i = 0; i < 4; i++) {
        vec4 values = camera.whole * vertex.vertexData[tetrahedron2[i]];
        vec3 screen = values.xyz / values.w;
        screenSpace2[i] = screen;
        min2 = min(min2, screen.xy);
        max2 = max(max2, screen.xy);
    }
    // Check AABBs?
    // Caching of sorting in order to reduce load?
    // TODO Test if all points are within an other primitives
    const uint[5] index1 = sortPoints(screenSpace1, left1, right1);
    const uint[5] index2 = sortPoints(screenSpace2, left2, right2);
    vec2 pointToTest;
    if(!getTestPoint(screenSpace1, index1, screenSpace2, index2, pointToTest))
        return;
    // TODO
    float z1 = 0;
    float z2 = 0;
    if(((v1 & k) == 0 && z1 <= z2) ||
       ((v1 & k) != 0 && z1 >= z2))
       return;
    uint temp = toSort[v1];
    toSort[v1] = toSort[v2];
    toSort[v2] = temp;
}

void main() {
    uint ij = gl_WorkGroupID.x ^ j;
    if (ij > gl_WorkGroupID.x) {
        compareAndSwap(gl_WorkGroupID.x, ij);
    }
}

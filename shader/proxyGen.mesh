#version 460

#extension GL_EXT_mesh_shader : require
#extension GL_EXT_fragment_shading_rate : disable

#define FLT_MAX 3.402823466e+38
#define FLT_MIN 1.175494351e-38

layout (local_size_x=128) in;

layout (triangles) out;
layout (max_vertices=5, max_primitives=4) out;

layout (binding=0) uniform Camera {
    mat4 model;
    mat4 view;
    mat4 proj;
} camera;
layout (binding=1) buffer Index {
    uvec4 data[];
} index;
layout (binding=2) buffer Vertex {
    vec4 vertexData[];
} vertex;

layout(push_constant) uniform PushConsts {
    uint offset;
} push;

bool onAABB(vec2 p, vec2 minAABB, vec2 maxAABB) {
    return minAABB.x == p.x || maxAABB.x == p.x || minAABB.y == p.y || maxAABB.y == p.y;
}

void main() {
    const uint i = gl_WorkGroupID.x;
    const uvec4 tetrahedron = index.data[i + push.offset];
    
    vec2 screenSpace[4];
    vec2 aabbMax = vec2(FLT_MIN, FLT_MIN);
    vec2 aabbMin = vec2(FLT_MAX, FLT_MAX);
    for(uint x = 0; x < 4; x++) {
        vec4 world = camera.model * vertex.vertexData[tetrahedron[x]];
        vec4 screen = camera.view * world;
        vec2 screen2D = screen.xy / screen.w;
        aabbMax = max(screen2D, aabbMax);
        aabbMin = min(screen2D, aabbMin);
        screenSpace[x] = screen2D;
        vec4 projection = camera.proj * screen;
        gl_MeshVerticesEXT[x].gl_Position = projection;
    }
    
    uint triangleOuter[3];
    uint inner = 0;
    uint addition = 0;
    for(uint x = 0; x < 4; x++) {
        if(!onAABB(screenSpace[x], aabbMin, aabbMax)) {
            addition = 1;
            inner = x;
            continue;
        }
        triangleOuter[x - addition] = x;
    }

}

#version 460

#extension GL_EXT_mesh_shader : require

#define FLT_MAX 3.402823466e+38
#define FLT_MIN 1.175494351e-38

layout (local_size_x=128) in;

layout (triangles) out;
layout (max_vertices=5, max_primitives=4) out;

layout(location=0) perprimitiveEXT out vec3 lambdasOut[];

layout (binding=0) uniform Camera {
    mat4 model;
    mat4 view;
    mat4 proj;
} camera;
layout (binding=1) buffer Index {
    uvec4 data[];
} index;
layout (binding=2) buffer Vertex {
    vec4 vertexData[];
} vertex;

layout(push_constant) uniform PushConsts {
    uint offset;
} push;

bool onAABB(vec2 p, vec2 minAABB, vec2 maxAABB) {
    return minAABB.x == p.x || maxAABB.x == p.x || minAABB.y == p.y || maxAABB.y == p.y;
}

float distToLine(vec2 l1, vec2 l2, vec2 p) {
    vec2 Md = l2 - l1;
    vec2 n = vec2(Md.y, -Md.x);
    vec2 dir = l1 - p;
    return abs(dot(normalize(n), dir));
}

void main() {
    const uint i = gl_WorkGroupID.x;
    const uvec4 tetrahedron = index.data[i + push.offset];
    
    vec2 screenSpace[4];
    uint mostLeft = 0;
    float currentX = FLT_MAX;
    uint mostRight = 0;
    float currentXRight = -FLT_MAX;
    for(uint x = 0; x < 4; x++) {
        vec4 world = camera.model * vertex.vertexData[tetrahedron[x]];
        vec4 screen = camera.view * world;
        vec2 screen2D = screen.xy / screen.w;
        if(currentX > screen2D.x) {
            mostLeft = x;
            currentX = screen2D.x;
        }
        if(currentXRight < screen2D.x) {
            mostRight = x;
            currentXRight = screen2D.x;
        }
        screenSpace[x] = screen2D;
        vec4 projection = camera.proj * screen;
        gl_MeshVerticesEXT[x].gl_Position = projection;
    }
    
    float distanceToLine = 0;
    uint mostDistantOne = 0;
    for(uint x = 0; x < 4; x++) {
        if(mostRight == x || mostLeft == x) {
            continue;
        }
        float dist = distToLine(mostLeft, mostRight, screenSpace[x]);
        if(dist > distanceToLine) {
            
        }
    }
    vec2 P2 = screenSpace[triangleOuter[2]];
    vec2 dP0 = screenSpace[triangleOuter[0]] - P2;
    vec2 dP1 = screenSpace[triangleOuter[1]] - P2;
    vec2 dP3 = screenSpace[inner] - P2;
    float faktor = 1.0/(dP0.y * dP1.x - dP0.x * dP1.y);
    // Multiply inverse
    vec2 lambdas = faktor * vec2(dP1.x * dP3.y - dP1.y * dP3.x, dP0.y * dP3.x - dP0.x * dP3.y);
    if(lambdas.x <= 0.0f || lambdas.y <= 0.0f || lambdas.x >= 1.0f - lambdas.y) {
        // Case 2
        
    } else {
        // Case 1
        gl_PrimitiveTriangleIndicesEXT[0] = uvec3(triangleOuter[0], triangleOuter[1], inner);
        gl_PrimitiveTriangleIndicesEXT[1] = uvec3(triangleOuter[1], triangleOuter[2], inner);
        gl_PrimitiveTriangleIndicesEXT[2] = uvec3(triangleOuter[2], triangleOuter[0], inner);
        vec3 lambdasFin = vec3(lambdas, 1 - lambdas.x - lambdas.y);
        lambdasOut[0] = lambdasFin;
        lambdasOut[1] = lambdasFin;
        lambdasOut[2] = lambdasFin;
        SetMeshOutputsEXT(4, 3);
    }
}

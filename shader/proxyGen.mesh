#version 460

#extension GL_EXT_mesh_shader : require

#define FLT_MAX 3.402823466e+38
#define FLT_MIN 1.175494351e-38

layout (local_size_x=128) in;

layout (triangles) out;
layout (max_vertices=5, max_primitives=4) out;

// Debug Out
layout(location=2) perprimitiveEXT out vec3 lambdasOut[];
// Depth output
layout(location=0) out float depthsMin[];
layout(location=1) out float depthsMax[];

layout (binding=0) uniform Camera {
    mat4 model;
    mat4 view;
    mat4 proj;
} camera;
layout (binding=1) buffer Index {
    uvec4 data[];
} index;
layout (binding=2) buffer Vertex {
    vec4 vertexData[];
} vertex;

layout(push_constant) uniform PushConsts {
    uint offset;
} push;

bool onAABB(vec2 p, vec2 minAABB, vec2 maxAABB) {
    return minAABB.x == p.x || maxAABB.x == p.x || minAABB.y == p.y || maxAABB.y == p.y;
}

float aboveLine(vec2 l1, vec2 l2, vec2 p) {
    vec2 Md = l2 - l1;
    vec2 n = vec2(Md.y, -Md.x);
    vec2 dir = l1 - p;
    return dot(normalize(n), dir);
}

float distToLine(vec2 l1, vec2 l2, vec2 p) {
    return abs(aboveLine(l1, l2, p));
}

void main() {
    const uint i = gl_WorkGroupID.x;
    const uvec4 tetrahedron = index.data[i + push.offset];
    
    vec2 projectionDepths[4];
    vec2 screenSpace[4];
    uint mostLeft = 0;
    float currentX = FLT_MAX;
    uint mostRight = 0;
    float currentXRight = -FLT_MAX;
    bool allNot = false;
    for(uint x = 0; x < 4; x++) {
        vec4 world = camera.model * vertex.vertexData[tetrahedron[x]];
        vec4 screen = camera.view * world;
        vec4 projection = camera.proj * screen;
        gl_MeshVerticesEXT[x].gl_Position = vec4(projection.xy, 0, projection.w);
        vec2 screen2D = projection.xy / projection.w;
        projectionDepths[x] = projection.zw;
        if(!allNot && !(screen2D.x < -1 || screen.x > 1 || screen2D.y < -1 || screen.y > 1))
            allNot = true;
        if(currentX > screen2D.x) {
            mostLeft = x;
            currentX = screen2D.x;
        }
        if(currentXRight < screen2D.x) {
            mostRight = x;
            currentXRight = screen2D.x;
        }
        screenSpace[x] = screen2D;
    }
    // Clipping
    if(!allNot)
        return;
    
    float distanceToLine = 0;
    uint mostDistantOne = 0;
    uint otherDist = 4;
    for(uint x = 0; x < 4; x++) {
        if(mostRight == x || mostLeft == x) {
            continue;
        }
        float dist = distToLine(screenSpace[mostLeft], screenSpace[mostRight], screenSpace[x]);
        if(dist > distanceToLine) {
            distanceToLine = dist;
            mostDistantOne = x;
            if(otherDist == 4)
                otherDist = mostDistantOne;
        } else {
            otherDist = x;
        }
    }
    uint triangleOuter[3] = { mostLeft, mostRight, mostDistantOne };

    vec2 P2 = screenSpace[mostDistantOne];
    vec2 dP0 = screenSpace[mostLeft] - P2;
    vec2 dP1 = screenSpace[mostRight] - P2;
    vec2 dP3 = screenSpace[otherDist] - P2;
    float faktor = dP0.y * dP1.x - dP0.x * dP1.y;
    // Multiply inverse
    vec2 lambdas = vec2(dP1.x * dP3.y - dP1.y * dP3.x, dP0.y * dP3.x - dP0.x * dP3.y) / faktor;
    float lambda2 = 1.0f - lambdas.y - lambdas.x;
    if(false && (lambdas.x <= 0.0f || lambdas.y <= 0.0f || lambda2 <= 0.0f)) {
        // Case 2
        float p2Dist = aboveLine(screenSpace[mostLeft], screenSpace[mostRight], P2);
        float p3Dist = aboveLine(screenSpace[mostLeft], screenSpace[mostRight], screenSpace[otherDist]);

        uvec2 lineOne;
        uvec2 lineTwo;
        if(sign(p2Dist) != sign(p3Dist)) {
            // Case: Line is bisecting the quad
            lineOne.x = mostLeft;
            lineOne.y = mostRight;
            lineTwo.x = otherDist;
            lineTwo.y = mostDistantOne;
        } else {
            // Case: We need to find the bisection point
            vec2 baseline = normalize(screenSpace[mostRight] - screenSpace[mostLeft]);
            
            float w1 = dot(baseline, normalize(screenSpace[mostRight] - screenSpace[otherDist]));
            float w2 = dot(baseline, normalize(screenSpace[mostRight] - screenSpace[mostDistantOne]));
            lineOne.x = mostLeft;
            lineOne.y = mostDistantOne;
            lineTwo.x = mostRight;
            lineTwo.y = otherDist;
            if(w1 < w2) {
                lineOne.y = otherDist;
                lineTwo.y = mostDistantOne;
            }
        }

        vec2 P1 = screenSpace[lineOne.y];
        vec2 dP31 = screenSpace[lineOne.x] - P1;
        vec2 dP20 = screenSpace[lineTwo.x] - screenSpace[lineTwo.y];
        vec2 dP01 = screenSpace[lineTwo.y] - P1;
        
        float s = (dP01.x * dP20.y - dP01.y  * dP20.x) / (dP31.x * dP20.y - dP31.y  * dP20.x);
        vec2 midpoint = P1 + dP31 * s;
        float t = dot(dP20, midpoint - screenSpace[lineTwo.y]) / dot(dP20, dP20);

        gl_MeshVerticesEXT[4].gl_Position = vec4(midpoint, 0.0f, 1.0f);

        gl_PrimitiveTriangleIndicesEXT[0] = uvec3(lineOne.y, lineTwo.y, 4);
        gl_PrimitiveTriangleIndicesEXT[1] = uvec3(lineOne.y, lineTwo.x, 4);
        gl_PrimitiveTriangleIndicesEXT[2] = uvec3(lineOne.x, lineTwo.y, 4);
        gl_PrimitiveTriangleIndicesEXT[3] = uvec3(lineOne.x, lineTwo.x, 4);

        lambdasOut[0] = vec3(midpoint, s);
        lambdasOut[1] = vec3(lineOne, sign(p2Dist));
        lambdasOut[2] = vec3(lineTwo, sign(p3Dist));
        lambdasOut[3] = vec3(screenSpace[lineTwo.x], 1);

        for(uint x = 0; x < 4; x++) {
            vec2 vz = projectionDepths[x];
            float z = vz.x / vz.y;
            depthsMin[x] = z;
            depthsMax[x] = z;
        }
        vec2 va = projectionDepths[lineOne.x];
        vec2 vc = projectionDepths[lineOne.y];
        vec2 vb = projectionDepths[lineTwo.x];
        vec2 vd = projectionDepths[lineTwo.y];
        float oneZ0 = 1.0f / (va.y / va.x * (1 - t) + vc.y / vc.x * t);
        float oneZ1 = 1.0f / (vb.y / vb.x * (1 - s) + vd.y / vd.x * s);

        depthsMin[4] = min(oneZ0, oneZ1);
        depthsMax[4] = max(oneZ0, oneZ1);

        SetMeshOutputsEXT(5, 4);
    } else {
        float[] lambdaArray = {lambdas.x, lambdas.y, lambda2};
        float z1 = 0;
        for(uint x = 0; x < 3; x++) {
            uint id = triangleOuter[x];
            vec2 vz = projectionDepths[id];
            float z = vz.x / vz.y;
            depthsMin[id] = z;
            depthsMax[id] = z;
            z1 += (vz.y / vz.x) * lambdaArray[x];
        }
        vec2 vz = projectionDepths[otherDist];
        float z0 = vz.x / vz.y;
        float oneZ1 = 1.0f / z1;
        depthsMin[otherDist] = min(z0, oneZ1);
        depthsMax[otherDist] = max(z0, oneZ1);

        // Case 1
        gl_PrimitiveTriangleIndicesEXT[0] = uvec3(triangleOuter[0], triangleOuter[1], otherDist);
        gl_PrimitiveTriangleIndicesEXT[1] = uvec3(triangleOuter[1], triangleOuter[2], otherDist);
        gl_PrimitiveTriangleIndicesEXT[2] = uvec3(triangleOuter[2], triangleOuter[0], otherDist);
        
        lambdasOut[0] = vec3(lambdas, 1);
        lambdasOut[1] = vec3(lambdas, 1);
        lambdasOut[2] = vec3(lambdas, 1);
        SetMeshOutputsEXT(4, 3);
    }
}
